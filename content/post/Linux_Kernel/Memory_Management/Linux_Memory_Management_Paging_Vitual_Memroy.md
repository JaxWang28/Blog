---
title: Linux-内存管理 - 分页虚拟存储理论
slug: linux-memory-paging-fundamental
share: true
draft: false
date: 2025-04-26T14:37:06+08:00
tags:
  - Linux
  - Kernel
categories:
---


# 0x01 虚拟存储器 Virtual Memory

Virtual Memroy[1] 由 Fotheringham 在 1961 年提出[2]，其基本思想是：
* 程序的代码数据和栈的总大小可以超过物理内存（RAM）
* 操作系统将正在运行的程序的需要的那部分保留在内存中，而将当前不使用的部分放置在磁盘上，根据需要调入内存。

根据虚拟存储器实现的技术可以分为：
1. 页式：采用**分页 Paging **技术
2. 段式：采用**分段 Segmentation **技术
3. 分页分段结合：Paged Segmentation

目前大多数虚拟存储管理系统都采用**分页 paging ** 技术，本文也仅讲解分页存储管理。


# 0x02 分页基本思想

* 将物理内存划分为为许多固定大小的内存块 ，称为**物理页面 页框 page frame**。
* 将程序中使用的地址称为**虚拟地址**，并构成**虚拟地址空间**。将虚拟地址空间划分为大小相同的块，称为**虚拟页面 page**。
* CPU 访问程序中使用的地址时，并不是放在地址总线上，而是被送往**存储管理单元 MMU**，其将虚拟地址转化为物理地址后再进行访问。

**Example**
* RAM 大小为 16KB，程序的虚拟地址空间为 32KB
* 物理内存被划分为 4 个 4KB 大小的页框
* 虚拟地址空间被划分为 8 个 4KB 大小的虚拟页面。
* 此时系统中的映射关系如下:

![](https://img.jaxwang.top/2025/04/deaeef83c0af4f43e37743d248eda759.png)

```
MOVE REG,0x3000
```

启用分页虚拟内存后，CPU 并不会直接访问 `0x3000` ，而是将 `0x3000` 地址送往 MMU，MMU 根据上述映射关系，计算出物理地址为 `0x1000`，进而将 `0x1000` 处内容放在寄存器中。


# 0x03 页表

用来记录 **虚拟页面->物理页面** 之间的映射关系，换而言之，**页表保存了虚拟地址到物理地址之间的映射关系**。

从数学的角度讲，页表就是一个函数，MMU 利用这个函数，输入虚拟页面号，得到物理页面号。

这里的关键时输入集合是虚拟页面，因此页框大小不变的情况下，虚拟地址空间越大，所需的页表也会越大，而不是取决于物理内存的大小。

根据前文例子中的映射关系，可以得到如下简易的页表：

![](https://img.jaxwang.top/2025/04/dc550f843a67e32b72b9cae4255a6b7e.png)

对于页表两个需要关注的问题：
* 页表占据的空间
* 页表的映射速度

关于页表的空间，假设虚拟地址空间大小为 4GB，页框大小为 4KB，所需要的表项达到了 100 万个。而在 Linux 中，每个进程的虚拟地址空间都是独立的，每个进程都它自己的页表，总的页表体积非常大，因此常需要使用多级页表来解决这个问题。


# 0x04 MMU 工作原理

* 将虚拟地址视为 `|虚拟页面号|页内偏移地址|`
* 虚拟页面号 --页表--> 物理页面号
* `|物理页面号|页内偏移地址|` -> 物理地址

**Example** `MOVE REG, 0x3000`：
* 0x`3|000` 虚拟页面号为 3 ,页内偏移地址为 `0x000`
* 根据页表 3 -> 1
* 物理地址 0x`1|000`


# 0x05 多级页表

多级页表的理论基础是，当进程运行时通常不会用到所有的虚拟地址空间。所以页表并不需要所有的页表项。

**Example** 
虚拟地址为 32 位（虚拟地址空间为 4GB），页面大小为 4KB。
如果采用普通页表，虚拟页面号占 20 位，页内偏移地址占 12 位。所需的页表项数目为 `2^20` ，这是个非常庞大的数字。

假设一个进程需要的内存空间仅为 12MB（而我们的虚拟地址空间可达 4GB），最低端的 4MB 程序代码，4MB 用来存储数据，最顶端的 4MB 用作栈。可以设计如下两级页表：

![](https://img.jaxwang.top/2025/04/39a1d5c4b9207c759375e219721eb956.png)

* 建立 1 张一级页表，含有 1024 个页目录项，每项为一个地址或一个空值，该地址为一个二级页表的位置。
* 建立 3 张二级页表，每个页表含有 1024 个表项，每个表项为一个物理页面号，即指向物理地址。每个页面为 4KB，因此每个二级页表即可指向 4MB 的地址空间。

多级页表的 MMU 工作方式：

**Example** 
```
0x00400004
```

![](https://img.jaxwang.top/2025/04/66c16a5daa2d0d28cbcb5ac4b6e6eafc.png)


# 0x06 页表项的结构

页表项的核心是存储物理页面号，通常还需要存储一些属性来实现某些功能。不同的 CPU 及操作系统对页表项的设计是不同的。如下是一个典型的页表项：

![](https://img.jaxwang.top/2025/04/ebe9823cc478c255f049604b1e76d20e.png)

* 保护位：表示允许对这个页面的操作是可读，可写，可读写。
* 修改位：表示页面中的内容是否被修改过。也称为**脏位**。当一个页面需要被换下存到磁盘时，如果没有修改过就不需要将这部分内容存入磁盘。此时磁盘与内从中的内容是一致的。
* 访问位：表示页面是否被访问过。用于页面置换算法，可优先置换掉没有被访问过的页面。
* 有效位：表示这个页面是否在内存中。如果不在内存中则无效，此时 MMU 会产生一个缺页中断给 CPU，要求 CPU 将相应的页面置换到内存。
* 禁用缓存位：表示页面是否可以被缓存。主要用于某些页面被映射到设备寄存器而不是 RAM。



# 0x07 关联存储器 TLB Transition Lookaside Buffer 
绝大多数进程运行时，倾向于集中访问一小部分页面。一部分页表项会经常使用，这是局部性的一种体现。

根据这个观察，设计出一种硬件，用来存储常用的页表项。
当 MMU 根据虚拟页面号寻找页表项时首先从 TLB 中查找。而不需要在内存中查找页表项，减少了对内存的访问。

如果 TLB 中没有，则在内存中的页表找到对应页表项，并在 TLB 中驱逐一个页表项，把需要访问的那个页表项放在 TLB 中。


# 0x08 页面置换算法

**TODO**


# 0x09 Ref.
[1] https://en.wikipedia.org/wiki/Virtual_memory
[2] https://dl.acm.org/doi/pdf/10.1145/366786.366800
